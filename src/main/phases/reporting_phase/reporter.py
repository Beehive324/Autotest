from datetime import datetime
from langchain_core.tools import tool
import requests
import nmap
from typing import Optional, List, Dict, Type, Any
from pydantic import BaseModel, Field
from langgraph.graph import StateGraph, START, END
from langchain_core.messages import AIMessage, HumanMessage
from langchain_core.tools import BaseTool
from langchain.tools import Tool
from .tools.reporting_tools import WriteReport
from IPython.display import Image, display
from langgraph.checkpoint.memory import InMemorySaver
from langgraph.prebuilt import create_react_agent
from langgraph_swarm import create_handoff_tool, create_swarm
from langchain_core.runnables import Runnable, RunnableConfig
from fpdf import FPDF
from langchain_ollama import ChatOllama
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough
from ..orchestrator.memory import PenTestState

class Reporter(Runnable):
    def __init__(self, model):
        self.model = model
        self.tools = [WriteReport()]
        self.name = "reporter"
        
        # Create specialized sub-agents
        self.report_generator = create_react_agent(
            model,
            [WriteReport(), create_handoff_tool(agent_name="report_analyzer")],
            prompt="""You are a pentesting report writer. Your task is to generate comprehensive reports based on findings.
            Format the report with clear sections for:
            1. Executive Summary
            2. Methodology
            3. Findings
            4. Risk Assessment
            5. Recommendations
            Use markdown-style formatting for better readability.""",
            name="report_generator"
        )
        
        self.report_analyzer = create_react_agent(
            model,
            [create_handoff_tool(agent_name="report_generator")],
            prompt="You are a report analysis expert. Your task is to analyze and validate report content.",
            name="report_analyzer"
        )
        
        # Create the swarm
        self.checkpointer = InMemorySaver()
        self.workflow = create_swarm(
            [self.report_generator, self.report_analyzer],
            default_active_agent="report_generator"
        )
        self.app = self.workflow.compile(checkpointer=self.checkpointer)

    @property
    def input_schema(self) -> Type[PenTestState]:
        """Return the input schema type."""
        return PenTestState

    @property
    def output_schema(self) -> Type[PenTestState]:
        """Return the output schema type."""
        return PenTestState

    def invoke(self, state: PenTestState, config: Optional[RunnableConfig] = None, **kwargs) -> PenTestState:
        """Synchronously invoke the reporter agent.
        
        Args:
            state: The current state of the pentest
            config: Optional configuration dictionary
            **kwargs: Additional keyword arguments
            
        Returns:
            Updated state after reporting phase
        """
        try:
            config = config or {"configurable": {"thread_id": state.ip_port}}
            
            # Generate initial report
            turn_1 = self.app.invoke(
                {
                    "messages": [
                        {
                            "role": "user",
                            "content": f"Generate a comprehensive report for target {state.ip_port} with the following findings:\n" +
                                     f"Vulnerabilities: {state.vulnerabilities}\n" +
                                     f"Open Ports: {state.open_ports}\n" +
                                     f"Services: {state.services}"
                        }
                    ]
                },
                config
            )
            
            # Analyze and validate report
            turn_2 = self.app.invoke(
                {
                    "messages": [
                        {
                            "role": "user",
                            "content": "Analyze and validate the generated report for completeness and accuracy"
                        }
                    ]
                },
                config
            )
            
            # Update state with report
            report = turn_1.get("report", "")
            state.messages.append(AIMessage(content=f"Report generated successfully. Analysis complete."))
            
            # The PDF will be generated by the WriteReport tool
            state.messages.append(AIMessage(content=f"PDF report has been generated."))
            
            return state
            
        except Exception as e:
            error_message = f"Error in reporting phase: {str(e)}"
            state.messages.append(AIMessage(content=error_message))
            return state
    
    async def ainvoke(self, state: PenTestState, config: Optional[RunnableConfig] = None, **kwargs) -> PenTestState:
        """Asynchronously invoke the reporter agent.
        
        Args:
            state: The current state of the pentest
            config: Optional configuration dictionary
            **kwargs: Additional keyword arguments
            
        Returns:
            Updated state after reporting phase
        """
        try:
            config = config or {"configurable": {"thread_id": state.ip_port}}
            
            # Generate initial report
            turn_1 = await self.app.ainvoke(
                {
                    "messages": [
                        {
                            "role": "user",
                            "content": f"Generate a comprehensive report for target {state.ip_port} with the following findings:\n" +
                                     f"Vulnerabilities: {state.vulnerabilities}\n" +
                                     f"Open Ports: {state.open_ports}\n" +
                                     f"Services: {state.services}"
                        }
                    ]
                },
                config
            )
            
            # Analyze and validate report
            turn_2 = await self.app.ainvoke(
                {
                    "messages": [
                        {
                            "role": "user",
                            "content": "Analyze and validate the generated report for completeness and accuracy"
                        }
                    ]
                },
                config
            )
            
            # Update state with report
            report = turn_1.get("report", "")
            state.messages.append(AIMessage(content=f"Report generated successfully. Analysis complete."))
            
            # The PDF will be generated by the WriteReport tool
            state.messages.append(AIMessage(content=f"PDF report has been generated."))
            
            return state
            
        except Exception as e:
            error_message = f"Error in reporting phase: {str(e)}"
            state.messages.append(AIMessage(content=error_message))
            return state

    def get_tools(self) -> List[Tool]:
        return self.tools

    def get_agent(self) -> Runnable:
        """Get the agent runnable for use in the workflow.
        
        Returns:
            The agent runnable
        """
        return self.app
    
    def display_graph(self):
        # Save the graph visualization
        graph_path = 'reporting_workflow.png'
        # Compile the workflow first
        compiled_workflow = self.workflow.compile()
        # Use the compiled graph for visualization
        compiled_workflow.get_graph().draw_png(graph_path)
        print(f"Graph visualization saved to: {graph_path}")
        
        # Display the graph
        return display(Image(graph_path))

if __name__ == "__main__":
    # Initialize with Ollama model
    model = ChatOllama(model="llama2", temperature=1)
    reporter = Reporter(model)
    
    # Create a test state
    test_state = PenTestState(
        ip_port="example.com:80,443",
        open_ports=["80", "443"],
        input_message="Generate report for example.com",
        remaining_steps=5,
        planning_results={},
        vulnerabilities=[
            {
                "name": "Test Vulnerability",
                "severity": "High",
                "description": "Test vulnerability description",
                "affected_components": ["web server"]
            }
        ],
        services=["HTTP", "HTTPS"],
        subdomains=[],
        successful_exploits=[],
        failed_exploits=[],
        risk_score=7.5
    )
    
    # Run reporting phase (in async context)
    import asyncio
    result = asyncio.run(reporter.ainvoke(test_state))
    print("Report Generation Results:")
    print("Messages:", result.messages)